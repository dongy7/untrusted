/*
 * robotMaze.js
 *
 * The blue key is inside a labyrinth, and extracting
 * it will not be easy.
 *
 * It's a good thing that you're a AI expert, or
 * we would have to leave empty-handed.
 */

function startLevel(map) {
    // Hint: you can press R or 5 to "rest" and not move the
    // player, while the robot moves around.

    map.getRandomInt = function(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    map.placePlayer(map.getWidth()-1, map.getHeight()-1);
    var player = map.getPlayer();

    map.defineObject('robot', {
        'type': 'dynamic',
        'symbol': 'R',
        'color': 'gray',
        'onCollision': function (player, me) {
            me.giveItemTo(player, 'blueKey');
        },
        'behavior': function (me) {
            // goal: the empty tile above the key
            var goalX = map.getWidth() - 2;
            var goalY = 7;

            // BFS with pruning
            var findShortestPath = function(initX, initY) {
                // keep track of previous states
                var conj = function(prev, state) {
                    return { prev: prev, state: state };
                };

                // hash function for location
                var hash = function(x, y) {
                    return x + 'x' + y;
                };

                var visited = {};
                var queue = [];
                var initialState = { pos: [initX, initY], dir: null };

                queue.push(conj(null, initialState));
                var node;

                while (node = queue.shift()) {
                    var state = node.state;
                    var pos = state.pos;
                    visited[hash(pos[0], pos[1])] = true;

                    // check for goal
                    if (pos[0] === goalX && pos[1] === goalY) {
                        // reconstruct path
                        var path = [];
                        while(node) {
                            path.push(node.state.dir);
                            node = node.prev;
                        }

                        return path.reverse().slice(1);
                    }

                    var nextCells = map.getAdjacentEmptyCells(pos[0], pos[1]);

                    // get the next valid states to explore
                    var filteredCells = nextCells.filter(function(cell) {
                        var hashVal = hash(cell[0][0], cell[0][1]);
                        if (visited[hashVal]) {
                            return false;
                        } else {
                            // Don't queue states more than once
                            visited[hashVal] = true;
                            return true;
                        }
                    });

                    // push the unexplored states to the queue
                    for (var i = 0; i < filteredCells.length; i++) {
                           queue.push(conj(node, {
                            pos: filteredCells[i][0],
                            dir: filteredCells[i][1],
                        }));
                    }
                }
            };

            // First find shortest path to our goal
            if (me.path === undefined) {
                me.path = findShortestPath(me.getX(), me.getY());
            }

            // reached goal, just move down
            if (me.getX() === goalX && me.getY() >= goalY) {
                me.move('down');
            } else { // follow the shortest path
                me.move(me.path.shift());
            }
        }
    });

    map.defineObject('barrier', {
        'symbol': 'â–‘',
        'color': 'purple',
        'impassable': true,
        'passableFor': ['robot']
    });

    map.placeObject(0, map.getHeight() - 1, 'exit');
    map.placeObject(1, 1, 'robot');
    map.placeObject(map.getWidth() - 2, 8, 'blueKey');
    map.placeObject(map.getWidth() - 2, 9, 'barrier');

    var autoGeneratedMaze = new ROT.Map.DividedMaze(map.getWidth(), 10);
    autoGeneratedMaze.create( function (x, y, mapValue) {
        // don't write maze over robot or barrier
        if ((x == 1 && y == 1) || (x == map.getWidth() - 2 && y >= 8)) {
            return 0;
        } else if (mapValue === 1) { //0 is empty space 1 is wall
            map.placeObject(x,y, 'block');
        } else {
            map.placeObject(x,y,'empty');
        }
    });
}

function validateLevel(map) {
    map.validateExactlyXManyObjects(1, 'exit');
    map.validateExactlyXManyObjects(1, 'robot');
    map.validateAtMostXObjects(1, 'blueKey');
}

function onExit(map) {
    if (!map.getPlayer().hasItem('blueKey')) {
        map.writeStatus("We need to get that key!");
        return false;
    } else {
        return true;
    }
}
